/*
 * Copyright (c) Contributors, VPGsim Project http://fernseed.usu.edu
 * See CONTRIBUTORS.TXT for a full list of copyright holders.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the VPGsim Project nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Timers;

using log4net;
using Nini.Config;
using OpenMetaverse;

using OpenSim.Framework;
using OpenSim.Region.Framework;
using OpenSim.Region.Framework.Interfaces;
using OpenSim.Region.Framework.Scenes;

namespace vpgSummary {

    public class vpgSummaryModule : IRegionModule
    {
        //Configuration settings
        bool m_enabled;
        int m_loci = 5; //number of loci #TODO make this configurable
        int m_cycleTime;
        string m_plotPath; //Path to the folder where plots will be stored
        string m_scriptPath; //Path to the folder where plotting script is stored
        string m_logPath; //Path to the folder where logs will be stored
        int m_listenChannel; //module listens for commands on this channel
        string m_instanceTag; //unique string to identify files generated by this module instance

        //Set up logging and console messages
        static readonly ILog m_log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        //Member variables
        Scene m_scene;
        bool m_running = false; //are the summaries running?
        bool m_isBusy = false; //is a summary being calculated right now?
        int m_cycleCount = 0; //tracks how many times summaries have been calculated
        Timer m_cycleTimer = new Timer(); //Timer to replace the region heartbeat
        //Paths to log files
        string m_localDemographicsLog;
        string m_localHweLog;
        //Summary class instances
        Summary m_localSummary;
        Summary m_lastLocalSummary;
        Summary m_onDemandSummary;

        #region IRegionModule interface

        public void Initialise(Scene scene, IConfigSource config)
        {
            //Read configuration settings
            IConfig vpgSummaryConfig = config.Configs["vpgSummary"];
            if (vpgSummaryConfig != null)
            {
                m_enabled = vpgSummaryConfig.GetBoolean("enabled", true);
                m_cycleTime = vpgSummaryConfig.GetInt("cycle_time", 300);
                m_plotPath = vpgSummaryConfig.GetString("plot_path", "addon-modules/vpgsim/output/");
                m_logPath = vpgSummaryConfig.GetString("log_path", "addon-modules/vpgsim/output/");
                m_listenChannel = vpgSummaryConfig.GetInt("listen_channel", 3);
                m_instanceTag = vpgSummaryConfig.GetString("instance_tag", "myregion");
            }
            if (m_enabled)
            {
                m_scene = scene;
                m_log.WarnFormat("[vpgSummary]: Initialized region {0}", scene.RegionInfo.RegionName);
            }
        }

        public void PostInitialise()
        {
            if (m_enabled)
            {
                //Assemble the paths and file names we will be using
                m_localDemographicsLog = System.IO.Path.Combine(m_logPath, "local-" + m_instanceTag + "-demographics.log");
                m_localHweLog = System.IO.Path.Combine(m_logPath, "local-" + m_instanceTag + "-hwe.log");
                //Register for events
                m_scene.EventManager.OnChatFromClient += OnChat;
                m_scene.EventManager.OnChatFromWorld += OnChat;
                m_log.WarnFormat("[vpgSummary] PostInitialized region {0}", m_scene.RegionInfo.RegionName);
                //Set up timer events (but don't start them yet)
                m_cycleTimer.Elapsed += new ElapsedEventHandler(OnCycleTimer);
                m_cycleTimer.Interval = m_cycleTime * 1000;
                //Create Summary instances to hold data
                m_localSummary = new Summary(m_loci);
                m_lastLocalSummary = new Summary(m_loci);
                m_onDemandSummary = new Summary(m_loci);
            }
        }

        public void Close()
        {
        }

        public string Name
        {
            get { return "vpgSummaryModule"; }
        }

        public bool IsSharedModule
        {
            get { return true; }
        }

        #endregion

        void OnChat(Object sender, OSChatMessage chat)
        {
            if (chat.Channel != m_listenChannel)
            {
                return;
            }
            else if (m_isBusy)
            {
                m_log.Info("[vpgSummary] Module busy...");
                DialogToAll("Summary Module: Busy.  Try again in a minute...");
            }
            else
            {
                if (chat.Message.ToLower() == "stop")
                {
                    if (m_running == true)
                    {
                        m_log.Info("[vpgSummary] Stopping summary reports...");
                        DialogToAll("Summary Module: Stopping summary reports...");
                        m_running = false;
                        m_cycleTimer.Stop();
                    }
                    else
                    {
                        m_log.Info("[vpgSummary] Stop requested, but reports are not running...");
                        DialogToAll("Summary Module: Cannot stop summary reports because they are not running...");
                    }
                }
                else if (chat.Message.ToLower() == "start")
                {
                    if (m_running == false)
                    {
                        m_log.Info("[vpgSummary] Starting summary reports...");
                        DialogToAll("Summary Module: Starting summary reports...");
                        m_running = true;
                        m_cycleTimer.Start();
                        DoSummary(true);
                    }
                    else
                    {
                        m_log.Info("[vpgSummary] Start requested, but reports are already running...");
                        DialogToAll("Summary Module: Cannot start summary reports because they are already running...");
                    }
                }
                else if (chat.Message.ToLower() == "now")
                {
                    DialogToAll("Summary Module: Summarizing population data...");
                    DoSummary(false); //Summarize but do not log the data
                }
                else if (chat.Message.ToLower() == "reset")
                {
                    if (m_running == true) //Don't reset unless we have stopped first
                    {
                        m_log.Info("[vpgSummary] Reset requested, but reports must be stopped first...");
                        DialogToAll("Summary Module: Cannot reset summary reports because they are running...");
                    }
                    else
                    {
                        //Clear all logs, plots, and any stored global or local data
                        m_log.Info("[vpgSummary] Resetting summary reports...");
                        DialogToAll("Summary Module: Resetting summary reports...");
                        System.IO.File.Delete(m_localDemographicsLog);
                        System.IO.File.Delete(m_localHweLog);
                        System.IO.File.Delete(System.IO.Path.Combine(m_plotPath, "local-" + m_instanceTag + "-demographicsplot.jpg"));
                        System.IO.File.Delete(System.IO.Path.Combine(m_plotPath, "local-" + m_instanceTag + "-heterozygosityplot.jpg"));
                        System.IO.File.Delete(System.IO.Path.Combine(m_plotPath, "local-" + m_instanceTag + "-allelefrequencyplot.jpg"));
                        m_cycleCount = 0;
                        //Clear ALL stored summaries
                        ResetSummaries(true);
                    }
                }
                else
                {
                    m_log.Info("[vpgSummary] Invalid command...");
                    DialogToAll("Summary Module: Invalid command...");
                }
            }
        }


        void OnCycleTimer(object source, ElapsedEventArgs e)
        {
            m_isBusy = true;
            m_cycleTimer.Stop();
            DoSummary(true); //Summarize and log the data
            m_cycleCount++;
            m_isBusy = false;
            m_cycleTimer.Start();
        }


        void DoSummary(bool isScheduled)
        {
            //Summarize the local population data
            if (isScheduled)
            {
                //Summarize, log, and update the huds with the summary
                m_localSummary.SummarizePopulation(m_scene);
                string demLogString = m_localSummary.GetDemLogString(m_cycleCount);
                string hweLogString = m_localSummary.GetHweLogString(m_cycleCount);
                m_log.Debug("[vpgSummary] Scheduled local summary. Cycle:" + m_cycleCount + " Spore:" + m_localSummary.Spores + " Gamet:" + m_localSummary.Gametophytes + " Sporo:" + m_localSummary.Sporophytes);
                LogData(demLogString, hweLogString);
                FormatHudData(true);
            }
            else
            {
                //just summarize and update the huds with local summary data
                m_onDemandSummary.SummarizePopulation(m_scene);
                m_log.Debug("[vpgSummary] Unscheduled local summary. Spore:" + m_onDemandSummary.Spores + " Gamet:" + m_onDemandSummary.Gametophytes + " Sporo:" + m_onDemandSummary.Sporophytes);
                FormatHudData(false);
            }
        }

        private void LogData(string demLogString, string hweLogString)
        {
            System.IO.StreamWriter demographicsLog;
            System.IO.StreamWriter hweLog;
            //logging local data
            demographicsLog = System.IO.File.AppendText(m_localDemographicsLog);
            hweLog = System.IO.File.AppendText(m_localHweLog);
            demographicsLog.WriteLine(demLogString);
            hweLog.WriteLine(hweLogString);
            demographicsLog.Close();
            hweLog.Close();
        }


        void FormatHudData(bool isScheduled)
        {
            if (!isScheduled)
            {
                //Don't ResetSummaries for 'on demand' summaries
                string[] hudString = m_onDemandSummary.GetHudString(m_lastLocalSummary);
                m_onDemandSummary = new Summary(m_loci);
                UpdateHUDs(hudString);
            }
            else
            {
                string[] hudString = m_localSummary.GetHudString(m_lastLocalSummary);
                ResetSummaries(false);
                UpdateHUDs(hudString);
            }
        }

        private void UpdateHUDs(string[] hudString)
        {
            //Use yellow for HUD text.  It shows against sky, water, or land.
            Vector3 textColor = new Vector3(1.0f, 1.0f, 0.0f);
            lock (m_scene)
            {
                EntityBase[] everyObject = m_scene.GetEntities();
                SceneObjectGroup sog;
                foreach (EntityBase e in everyObject)
                {
                    if (e is SceneObjectGroup) //ignore avatars
                    {
                        sog = (SceneObjectGroup)e;
                        if (sog.Name.Length > 9)
                        {
                            //Avoid an error on objects with short names (and skip over all the plants, since they have 9 character names at most)
                            //HUD must be the correct major release # to work.  If you make changes that will break old huds, update the release number.Minor release numbers track non-breaking HUD changes.
                            if (sog.Name.Substring(0,8) == "vpgHUDv1")
                            {
                                //Place floating text on each named prim of the inworld HUD
                                foreach (SceneObjectPart labeledPart in sog.Parts)
                                {
                                    if (labeledPart.Name == "QtyvpgHUD")
                                        labeledPart.SetText(hudString[0], textColor, 1.0);
                                    else if (labeledPart.Name == "QtyChangevpgHUD")
                                        labeledPart.SetText(hudString[1], textColor, 1.0);
                                    else if (labeledPart.Name == "HaplotypevpgHUD")
                                        labeledPart.SetText(hudString[2], textColor, 1.0);
                                    else if (labeledPart.Name == "TotalvpgHUD")
                                        labeledPart.SetText(hudString[3], textColor, 1.0);
                                    else if (labeledPart.Name == "SporesvpgHUD")
                                        labeledPart.SetText(hudString[4], textColor, 1.0);
                                    else if (labeledPart.Name == "GametvpgHUD")
                                        labeledPart.SetText(hudString[5], textColor, 1.0);
                                    else if (labeledPart.Name == "SporovpgHUD")
                                        labeledPart.SetText(hudString[6], textColor, 1.0);
                                    else if (labeledPart.Name == "LocusvpgHUD")
                                        labeledPart.SetText(hudString[7], textColor, 1.0);
                                    else if (labeledPart.Name == "P1vpgHUD")
                                        labeledPart.SetText(hudString[8], textColor, 1.0);
                                    else if (labeledPart.Name == "P1ChangevpgHUD")
                                        labeledPart.SetText(hudString[9], textColor, 1.0);
                                    else if (labeledPart.Name == "HobsvpgHUD")
                                        labeledPart.SetText(hudString[10], textColor, 1.0);
                                    else if (labeledPart.Name == "HexpvpgHUD")
                                        labeledPart.SetText(hudString[11], textColor, 1.0);
                                }
                                sog.RootPart.SetText("         Spores:\nGametophytes:\n   Sporophytes:", new Vector3(1.0f, 1.0f, 0.0f), 1.0);
                            }
                        }
                    }
                }
            }
        }


        void ResetSummaries(bool clearAll)
        {
            //Saves the current summaries as the last summaries and then deletes the current summaries - or deletes all summaries if clearAll is true
            if (clearAll)
            {
                //Clear the 'last' summary data
                m_lastLocalSummary = new Summary(m_loci);
            }
            else
            {
                //copy current summaries to last summaries
                m_lastLocalSummary = m_localSummary;
            }
            m_localSummary = new Summary(m_loci);
        }


        void DialogToAll(string dialogMessage)
        {
            IDialogModule dialogMod = m_scene.RequestModuleInterface<IDialogModule>();
            if (dialogMod != null)
            {
                dialogMod.SendGeneralAlert(dialogMessage);
            }
        }
    }


    public class Summary
    {
        //A class to hold the values resulting from a single region or global summary and the methods to generate it.
        //Private member variables:
        //Haplotype counts for each lifestage
        int[] m_sporeHaplotypes;
        int[] m_gametHaplotypes;
        int[] m_sporoHaplotypes;
        //Heterozygous sporophyte counts
        int[] m_heterozygotes;
        //Counts for each lifestage
        int m_spores = 0;
        int m_gametophytes = 0;
        int m_sporophytes = 0;
        //Counts of dominant alleles in sporophytes
        float[] m_dominantAlleles;
        //Number of regions included in this Summary instance
        int m_regionCount = 0;
        //Count of loci
        int m_loci;
        //Count of haplotypes
        int m_haplotypes;

        //Public properties:
        public int[] SporeHaplotypes
        {
            get {return m_sporeHaplotypes;}
            set {m_sporeHaplotypes = value;}
        }

        public int[] GametHaplotypes
        {
            get {return m_gametHaplotypes;}
            set {m_gametHaplotypes = value;}
        }

        public int[] SporoHaplotypes
        {
            get {return m_sporoHaplotypes;}
            set {m_sporoHaplotypes = value;}
        }

        public int[] Heterozygotes
        {
            get {return m_heterozygotes;}
            set {m_heterozygotes = value;}
        }

        public int Spores
        {
            get {return m_spores;}
            set {m_spores = value;}
        }

        public int Gametophytes
        {
            get {return m_gametophytes;}
            set {m_gametophytes = value;}
        }

        public int Sporophytes
        {
            get {return m_sporophytes;}
            set {m_sporophytes = value;}
        }

        public float[] DominantAlleles
        {
            get {return m_dominantAlleles;}
            set {m_dominantAlleles = value;}
        }


        //Constructors
        public Summary(int loci)
        {
            //initialize lists with lengths based on # of loci
            m_loci = loci;
            m_haplotypes = Convert.ToInt32(Math.Pow(2, loci));
            m_sporeHaplotypes = new int[m_haplotypes];
            m_gametHaplotypes = new int[m_haplotypes];
            m_sporoHaplotypes = new int[m_haplotypes];
            m_heterozygotes = new int[loci];
            m_dominantAlleles = new float[loci];
        }

        //Public Methods
        public float GetAlleleFrequency(int locus)
        {
            //Calculates and returns the dominant allele frequency for a locus.
            float alleleFrequency = (float)Math.Round(m_dominantAlleles[locus] / (m_sporophytes * 2), 3);
            return alleleFrequency;
        }

        public float GetHetObserved(int locus)
        {
            //Calculates and returns the observed heterozygosity for a locus.
            float hetObserved = (float)Math.Round((float)m_heterozygotes[locus] / m_sporophytes, 3);
            return hetObserved;
        }

        public string GetDemLogString(int cycleCount)
        {
            //Returns demographics data formated for the demographics log
            string demLogString = cycleCount + "," + m_spores + "," + m_gametophytes + "," + m_sporophytes;
            return demLogString;
        }

        public string GetHweLogString(int cycleCount)
        {
            //Returns HWE data formatted for the HWE log
            string hweLogString = cycleCount + ",";
            if (m_sporophytes > 0)
            {
                //There are sporophytes so we have allele frequencies and heterozygosity values to log.
                for(int i=m_loci; i>=1; i--)
                {
                    float alleleFrequency = GetAlleleFrequency(i-1);
                    float hetObserved = GetHetObserved(i-1);
                    hweLogString = hweLogString + alleleFrequency + "," + hetObserved;
                    if (i>1)
                    {
                        //Put a comma after every value except the last one
                        hweLogString = hweLogString + ",";
                    }
                }
            }
            else
            {
                //There are no sporophytes so we can't calculate and log allele frequencies or heterozygosity.
                for(int i=m_loci; i>=1; i--)
                {
                    hweLogString = hweLogString + "NA,NA"; //We have to log something because blank lines foul up the plots
                    if (i>1)
                    {
                        hweLogString = hweLogString + ",";
                    }
                }
            }
            return hweLogString;
        }


        public string[] GetHudString(Summary lastSummary)
        {
            //Returns summary data as a list with a string for each prim of the inworld HUD
            string[] hudString = new string[12];
            hudString[2] = "Haplotype\n";
            hudString[3] = "Total\n";
            hudString[4] = "Spores\n";
            hudString[5] = "Gamet\n";
            hudString[6] = "Sporo\n";
            hudString[7] = "";
            hudString[8] = "p(1)\n";
            hudString[9] = "Change\n";
            hudString[10] = "H-obs\n";
            hudString[11] = "H-exp\n";
            int sporesChange = m_spores - lastSummary.Spores;
            int gametophytesChange = m_gametophytes - lastSummary.Gametophytes;
            int sporophytesChange = m_sporophytes - lastSummary.Sporophytes;
            hudString[0] = "Qty\n" + m_spores + "\n" + m_gametophytes + "\n" + m_sporophytes;
            hudString[1] = "Change\n" +sporesChange + "\n" + gametophytesChange + "\n" + sporophytesChange;
            for(int h=0; h<m_sporeHaplotypes.Length; h++)
            {
                int totalHaplotypes = m_sporeHaplotypes[h] + m_gametHaplotypes[h] + m_sporoHaplotypes[h];
                if (totalHaplotypes > 0) //If a haplotype isn't present, don't report it.
                {
                    //Only report information for haplotypes that exist.
                    hudString[2] = hudString[2] + Decimal2Binary(h) + "\n";
                    hudString[3] = hudString[3] + totalHaplotypes + "\n";
                    hudString[4] = hudString[4] + m_sporeHaplotypes[h] + "\n";
                    hudString[5] = hudString[5] + m_gametHaplotypes[h] + "\n";
                    hudString[6] = hudString[6] + m_sporoHaplotypes[h] + "\n";
                }
            }
            if (m_sporophytes > 0) //can't calculate hwe stats if there are no sporophytes
            {
                for(int i=(m_loci - 1); i>=0; i--)
                {
                    float alleleFrequency = GetAlleleFrequency(i);
                    hudString[7] = hudString[7] + "Locus" + (i+1) + "\n";
                    hudString[8] = hudString[8] + alleleFrequency + "\n";
                    hudString[9] = hudString[9] + Math.Round(alleleFrequency - lastSummary.GetAlleleFrequency(i), 3) + "\n";
                    float hetObserved = GetHetObserved(i);
                    float hetExpected = (float)Math.Round(2 * alleleFrequency * (1 - alleleFrequency), 3);
                    hudString[10] = hudString[10] + hetObserved + "\n";
                    hudString[11] = hudString[11] + hetExpected + "\n";
                }
            }
            return hudString;
        }

        public void SummarizePopulation(Scene m_scene)
        {
            //Summarize the population data for each scene in scenes
            List <String> names = new List <String>();
            lock (m_scene)
            {
                m_regionCount++;
                EntityBase[] everyObject = m_scene.GetEntities();
                foreach (EntityBase e in everyObject)
                {
                    if (e is SceneObjectGroup) // ignore avatars
                    {
                        SceneObjectGroup sog = (SceneObjectGroup)e;
                        names.Add(sog.Name);
                    }
                }
            }
            foreach (String name in names)
            {
                if (name.Length > 4) //avoid an exception on scene objects with short names
                {
                    String objectType = name.Substring(0,5);
                    if (objectType == "Spore")
                    {
                        m_spores++;
                        int haplo = Int32.Parse(name.Substring(5)); //Parse the haplotype from the object name
                        m_sporeHaplotypes[haplo]++;
                    }
                    else if (objectType == "Gamet")
                    {
                        m_gametophytes++;
                        int haplo = Int32.Parse(name.Substring(5)); //Parse the haplotype from the object name
                        m_gametHaplotypes[haplo]++;
                    }
                    else if (objectType == "Sporo")
                    {
                        m_sporophytes++;
                        int geno = Int32.Parse(name.Substring(5)); //Parse the genotype from the object name
                        int haplo1 = (m_haplotypes - 1) & geno;
                        m_sporoHaplotypes[haplo1]++;
                        int haplo2 = (geno >> m_loci) & (m_haplotypes - 1);
                        m_sporoHaplotypes[haplo2]++;
                        int locus = 1;
                        for(int i = 0; i<m_loci; i++)
                        {
                            if ((haplo1 & locus) == (haplo2 & locus))
                            {
                                //It is homozygous
                                if ((haplo1 & locus) == locus)
                                {
                                    //It is homozygous dominant so it has 2 dominant alleles
                                    m_dominantAlleles[i] = m_dominantAlleles[i] + 2;
                                }
                            }
                            else
                            {
                                //It is heterozygous so it has one dominant allele
                                m_heterozygotes[i]++;
                                m_dominantAlleles[i]++;
                            }
                            locus = locus * 2;
                        }
                    }
                }
            }
        }

        string Decimal2Binary(int decimalNumber)
        {
            //Convert a haplotype decimal integer to a human readable binary haplotype string
            int count = 0;
            string binary = "";
            string binaryDigit = "";
            List<string> binaryList = new List<string>();
            while ((count < m_loci) || (decimalNumber > 0))
            {
                binaryDigit = Convert.ToString((int)(decimalNumber%2));
                binaryList.Add(binaryDigit);
                decimalNumber /= 2;
                count++;
            }
            while (count > 0)
            {
                binary = binary + binaryList[count-1];
                count--;
            }
            return binary;
        }

    }
}
